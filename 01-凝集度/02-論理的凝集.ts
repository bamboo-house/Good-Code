// @ts-nocheck

/*
- 論理的に似たようなことをするものを集めたモジュール
- 例えば：フラグによって動作を変える
- aとbなどの関連が薄い処理が１つの関数に混在している
- この関数の実行側は内部構造を知っている状態で引数を渡す必要がある
*/

function logicalCohesion(flag: boolean) {
  if(flag) {
    a()
  }
  else {
    b()
  }
}


/*
- ユースケースが異なるが、処理が似ている実装をDRYにするときに気をつけなければならない
- 最初はユースケース1だけを想定すれば良かったが、その関数のままユースケース2を想定すると
  論理的凝集になる
- 最もやりがちで、やってはいけない処理
*/
function usecase1and2(isUsecase1: boolean) {
  a()
  b()
  // usecase1の時だけ実行する処理
  if (isUsecase1) {
    c()
  }
  d()
}


/*
- このように、論理的凝集にならないように気をつける
*/
function usecase1() {
  a()
  b()
  c()
  d()
}

function usecase2() {
  a()
  b()
  d()
}


/*
- ユースケースを分離せず再利用したくなる理由は、時間的凝集の関数に詳細な実装を書きすぎているから
- 1と2で重複が多いため再利用したくなるが、上のようにa,b,c,dを機能的凝集にすることでDRYにする必要がなくなる
*/